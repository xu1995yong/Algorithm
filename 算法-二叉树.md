##  二叉树层次遍历
```java
public void levelOrder(TreeNode root) {
    if (root == null)
        return ;
    Queue<TreeNode> queue = new LinkedList<TreeNode>();
    queue.add(root);

    while (queue.size() != 0) {
        TreeNode node = queue.poll();
        System.out.println(node.val);
        if (node.left != null) {
            queue.add(node.left);
        }
        if (node.right != null) {
            queue.add(node.right);
        }
    }
}
```

## 二叉树前序遍历（根左右）

```java
public List<Integer> preorderTraversal(TreeNode root) {
    List<Integer> list = new ArrayList<>();

    if (root == null) {
        return list;
    }
    Stack<TreeNode> stack = new Stack<>();
    stack.push(root);//根节点入栈
    while (!stack.isEmpty()) { //栈不为空时循环
        TreeNode node = stack.pop();//出栈一个节点
        list.add(node.val);
        if (node.right != null) {//右子节点入栈
            stack.push(node.right);
        }
        if (node.left != null) {//左子节点入栈
            stack.push(node.left);
        }
    }
    return list;
}
```

## 二叉树中序遍历（左根右）

```java
public List<Integer> inorderTraversal(TreeNode root) {
    List<Integer> list = new ArrayList<>();

    if (root == null)
        return list;
    Stack<TreeNode> stack = new Stack<>();
    TreeNode node = root;

    while (!stack.isEmpty() || node != null) { //栈不为空或者node节点不为空时循环
        while (node != null) { //当node节点不为空时循环，node节点入栈，然后node节点指向自己的左孩子
            stack.push(node);
            node = node.left;
        }
        node = stack.pop();//出栈一个元素并访问
        list.add(node.val);
        node = node.right; //node节点指向自己的右孩子
    }
    return list;
}
```
## 二叉树后序遍历（左右根）
```java
public List<Integer> postorderTraversal(TreeNode root) {
    List<Integer> result = new ArrayList<>();
    Deque<TreeNode> stack = new ArrayDeque<>();

    if (root == null) {
        return result;
    }

    TreeNode prev = null;
    stack.push(root);
    while (!stack.isEmpty()) {
        TreeNode curr = stack.peek();
        if (prev == null || prev.left == curr || prev.right == curr) { //curr 向下走
            if (curr.left != null) {
                stack.push(curr.left);
            } else if (curr.right != null) {//
                stack.push(curr.right);
            }
        } else if (curr.left == prev) { //说明curr上次遍历的是它的左节点，所以应该跳到右节点
            if (curr.right != null) {
                stack.push(curr.right);
            }
        } else {//输出该节点
            result.add(curr.val);
            stack.pop();
        }
        prev = curr;
    }
    return result;
}
```

##  翻转二叉树（求二叉树的镜像）

```java
public void invertBinaryTree(TreeNode root) {
    if (root == null) {
        return;
    }
    TreeNode temp = root.left;
    root.left = root.right;
    root.right = temp;

    invertBinaryTree(root.left);
    invertBinaryTree(root.right);
}
```

## 判断一个二叉树是否对称

```java
//方法一：递归
public boolean isSymmetric(TreeNode root) {
    return isMirror(root, root);
}
public boolean isMirror(TreeNode t1, TreeNode t2) {
    if (t1 == null && t2 == null) return true;
    if (t1 == null || t2 == null) return false;
    return (t1.val == t2.val)
        && isMirror(t1.right, t2.left)
        && isMirror(t1.left, t2.right);
}
//方法二：迭代
public boolean isSymmetric(TreeNode root) {
    Queue<TreeNode> q = new LinkedList<>();
    q.add(root);
    q.add(root);
    while (!q.isEmpty()) {
        TreeNode t1 = q.poll();
        TreeNode t2 = q.poll();
        if (t1 == null && t2 == null) continue;
        if (t1 == null || t2 == null) return false;
        if (t1.val != t2.val) return false;
        q.add(t1.left);
        q.add(t2.right);
        q.add(t1.right);
        q.add(t2.left);
    }
    return true;
}
```
## 二叉树的逐层遍历

```java
public List<List<Integer>> levelOrder(TreeNode root) {
    List<List<Integer>> ret = new ArrayList<List<Integer>>();
    if (root == null)
        return ret;
    Queue<TreeNode> queue = new LinkedList<TreeNode>();
    queue.add(root);

    while (queue.size() != 0) {
        List list = new ArrayList();
        for (int i = queue.size(); i > 0; i--){//逐层遍历二叉树
            TreeNode node = queue.poll();
            list.add(node.val);

            if (node.left != null) {
                queue.add(node.left);
            }
            if (node.right != null) {
                queue.add(node.right);
            }
        }
        ret.add(list);
    }
    return ret;
}
```
## 二叉树的右视图（二叉树的左视图）

```java
public List<Integer> rightSideView(TreeNode root) {
    List<Integer> res = new LinkedList<>();
    if (root == null){
        return res;
    }
    Queue<TreeNode> queue = new LinkedList<>();
    queue.add(root);
    TreeNode node;
    while (!queue.isEmpty()) {//逐层遍历二叉树
        for (int i = queue.size(); i > 0; i--) {
            node = queue.poll();
            if (node.left != null)
                queue.add(node.left);
            if (node.right != null)
                queue.add(node.right);
            if (i == 1)//每层最后一个
                res.add(node.val);
        }
    }
    return res;
}
```

## 二叉树的所有路径

```java
public List<String> binaryTreePaths(TreeNode root) {
    List<String> list = new ArrayList<>();
    if (root == null) {
        return list;
    }
    paths(root, "", list);
    return list;
}

public void paths(TreeNode node, String s, List<String> list) {
    if (node.left != null) {
        paths(node.left, s + node.val + "->", list);
    }
    if (node.right != null) {
        paths(node.right, s + node.val + "->", list);
    }
    if (node.left == null && node.right == null) {
        list.add(s + node.val);
    }
}
```

## 二叉树的最大深度

```java
//方法一：递归
public int maxDepth(TreeNode root) {
    if (root == null){
        return 0;
    }
    int leftDepth = maxDepth(root.left);
    int rightDepth = maxDepth(root.right);
    return Math.max(leftDepth, rightDepth) + 1;
}

//方法二：层次遍历法
public int maxDepth(TreeNode root) {
    int maxDepth = 0;
    if (root == null)
        return maxDepth;
    Queue<TreeNode> queue = new LinkedList<TreeNode>();
    queue.add(root);

    while (queue.size() != 0) {
        maxDepth++;
        int count = queue.size();
        while (count != 0) {
            TreeNode node = queue.poll();
            count--;
            if (node.left != null) {
                queue.add(node.left);
            }
            if (node.right != null) {
                queue.add(node.right);
            }
        }

    }
    return maxDepth;
}
```

## 二叉树的最小深度

```java
//方法一：
public int minDepth(TreeNode root) {
    if (root == null) {
        return 0;
    }
    int leftDepth = minDepth(root.left);
    int rightDepth = minDepth(root.right);
    if (leftDepth == 0) {
        return rightDepth + 1;
    } else if (rightDepth == 0) {
        return leftDepth + 1;
    } else {
        return Math.min(leftDepth, rightDepth) + 1;
    }
}
//方法二：层次遍历法
public int minDepth(TreeNode root) {
    if (root == null) {
        return 0;
    }
    Queue<TreeNode> queue = new LinkedList<>();
    queue.add(root);
    int depth = 1;
    while (!queue.isEmpty()) {
        for (int i = queue.size() - 1; i >= 0; i--) {
            TreeNode tem = queue.poll();
            if (tem.left == null && tem.right == null) { //层次遍历法，如果遇到一个叶子时直接返回
                return depth;
            }
            if (tem.left != null) {
                queue.add(tem.left);
            }
            if (tem.right != null) {
                queue.add(tem.right);
            }
        }
        depth++;
    }
    return depth;
}
```

## 二叉树转链表
```java
public void flatten(TreeNode root) {
    if (root == null) {
        return;
    }
    Stack<TreeNode> stack = new Stack<>();
    stack.push(root);
    while (!stack.empty()) {
        TreeNode node = stack.pop();
        if (node.right != null) {
            stack.push(node.right);
        }
        if (node.left != null) {
            stack.push(node.left);
        }
        // connect
        node.left = null;
        if (stack.empty()) {
            node.right = null;
        } else {
            node.right = stack.peek();
        }
    }
}
```
## 二叉树中和为某一值的路径

```java
public List<List<Integer>> FindPath(TreeNode root, int target) {
    List<List<Integer>> result = new ArrayList<>();
    if (root == null) {
        return result;
    }
    List<Integer> path = new ArrayList<>();
    int sum = 0;
    find(root, target, sum, result, path);
    return result;
}

public void find(TreeNode node, int target, int sum, List<List<Integer>> result, List<Integer> path) {
    if (node == null) {
        return;
    }
    sum += node.val;
    path.add(node.val);
    //如果当前节点是叶子节点，且根节点到当前节点的路径和等于目标值
    if (node.left == null && node.right == null && sum == target) {
        result.add(new ArrayList<>(path));
    }
    find(node.left, target, sum, result, path);
    find(node.right, target, sum, result, path);
    //执行到该处时，说明当前节点的左右子树均已遍历结束，则从路径中删除当前节点，路径回溯
    path.remove(path.size() - 1);
}
```

