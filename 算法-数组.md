## 删除排序数组中的重复数字

给定一个排序数组，在原数组中“删除”重复出现的数字，使得每个元素只出现一次，并且返回“新”的数组的长度。

```java
public int removeDuplicates(int[] nums) {
    if (nums.length == 0) {
        return 0;
    }
    int len = 1;      //len指当前数组中已经筛选出的非重复元素个数
    for (int i = 1; i < nums.length; i++) {
        if ( nums[i] != nums[len - 1]) {      //len-1 是非重复数组的最后一个数的下标
            nums[len] = nums[i];
            ++len;
        }
    }
    return len;
}
```

## 删除排序数组中的重复数字2

一个排序数组，删除其中的重复元素，使得每个数字最多出现两次，返回新的数组的长度。

```java
public int removeDuplicates(int[] nums) {
    if (nums == null || nums.length == 0)
        return 0;

    int len = 1;      //当前数组中已经筛选出的非重复元素个数, 数组第一个个元素直接计数
    //数组第二个元素，或有等于或少于一个重复元素被选出的元素
    for (int i = 1; i < nums.length; i++) {
        if (i == 1 || nums[i] != nums[len - 2]) {      
            nums[len] = nums[i];
            ++len;
        }
    }
    return len;
}
```

## 合并排序数组

合并两个有序升序的整数数组A和B变成一个新的数组。新数组也要有序。

```java
public int[] mergeSortedArray(int[] A, int[] B) {
    int[] arr = new int[A.length + B.length];
    int aIndex = 0;
    int bIndex = 0;
    for (int k = 0; k < arr.length; k++) {
        if (aIndex >= A.length) {
            arr[k] = B[bIndex];
            bIndex++;
        } else if (bIndex >= B.length) {
            arr[k] = A[aIndex];
            aIndex++;
        } else {
            if (A[aIndex] > B[bIndex]) {
                arr[k] = B[bIndex];
                bIndex++;
            } else {
                arr[k] = A[aIndex];
                aIndex++;
            }
        }
    }
    return arr;
}
```

## 数组中第k大元素

```java
//方法一：依旧借助快排的思想，
public int kthLargestElement(int k, int[] nums) {
    return partition(nums, 0, nums.length - 1, nums.length - k);
}
private int partition(int[] nums, int start, int end, int k) {
    if (start >= end) {
        return nums[k];
    }
    int left = start, right = end;
    int pivot = nums[(start + end) / 2];
    while (left <= right) {
        while (left <= right && nums[left] < pivot) {
            left++;
        }
        while (left <= right && nums[right] > pivot) {
            right--;
        }
        if (left <= right) {
            swap(nums, left, right);
            left++;
            right--;
        }
    }
    if (k <= right) {
        return partition(nums, start, right, k);
    }
    if (k >= left) {
        return partition(nums, left, end, k);
    }
    return nums[k];//
}    
private void swap(int[] nums, int i, int j) {
    int tmp = nums[i];
    nums[i] = nums[j];
    nums[j] = tmp;
}
//方法二：使用堆
```

## 数组划分

```java
public int partitionArray(int[] nums, int k) {
    if (nums == null || nums.length == 0) {
        return 0;
    }
    int left = 0;
    int right = nums.length - 1;
    while (left <= right) {
        while (left <= right && nums[left] < k) {
            left++;
        }
        while (left <= right && nums[right] >= k) {
            right--;
        }
        if (left <= right) {
            int temp = nums[left];
            nums[left] = nums[right];
            nums[right] = temp;
            left++;
            right--;
        }
    }
    return left;
}
```

## 最大子数组

给定一个整数数组，找到一个具有最大和的子数组，返回其最大和。

```java
public int maxSubArray(int[] A) {
    if (A == null || A.length == 0){
        return 0;
    }
    int max = Integer.MIN_VALUE;
    int sum = 0;
    for (int i = 0; i < A.length; i++) {
        sum += A[i];//sum记录从A[0]到A[i]之间的数的和
        max = Math.max(max, sum);  //现在子数组的最大值
        sum = Math.max(sum, 0);//如果sum小于零，则sum重新置零（放弃之前的各数和）
    }
    return max;
}
```

## 最大子数组 II

给定一个整数数组，找出两个 *不重叠* 子数组使得它们的和最大。每个子数组的数字在数组中的位置应该是连续的。
返回最大的和。

```java
public int maxTwoSubArrays(List<Integer> nums) {
    if (nums == null || nums.size() == 0) {
        return 0;
    }
    int[] left = new int[nums.size()];// 记录从0到当前位置(i)下的最大子数组的和
    int[] right = new int[nums.size()];// 记录从i至size-1中最大子数组的和
    int lsum = 0;
    int lmax = Integer.MIN_VALUE;
    for (int i = 0; i < nums.size(); i++) {
        lsum += nums.get(i);
        lmax = Math.max(lmax, lsum);
        left[i] = lmax;
        lsum = Math.max(lsum, 0);
    }
    int rsum = 0;
    int rmax = Integer.MIN_VALUE;
    for (int j = nums.size() - 1; j > -1; j--) {
        rsum += nums.get(j);
        rmax = Math.max(rmax, rsum);
        right[j] = rmax;
        rsum = Math.max(rsum, 0);
    }
    int max = Integer.MIN_VALUE;
    for (int i = 0; i < nums.size() - 1; i++) {
        max = Math.max(max, left[i] + right[i + 1]);
    }
    return max;
}
```
## 最大子数组 III

给定一个整数数组和一个整数 *k*，找出 *k* 个**不重叠**子数组使得它们的和最大。每个子数组的数字在数组中的位置应该是**连续**的。

## 最小子数组

给定一个整数数组，找到一个具有最小和的子数组。返回其最小和。

```java
public int minSubArray(List<Integer> nums) {
    if (nums == null || nums.size() == 0){
        return 0;
    }
    int min = Integer.MAX_VALUE;
    int sum = 0;
    for (int i = 0; i < nums.size(); i++) {
        sum += nums.get(i);
        min = Math.min(min, sum);
        sum = Math.min(sum, 0);
    }
    return min;
}
```

## 最大子数组差

给定一个整数数组，找出两个**不重叠**的子数组A和B，使两个子数组和的差的绝对值**|SUM(A) - SUM(B)|**最大

```java
public int maxDiffSubArrays(int[] nums) {
    if (nums == null || nums.length == 0) {
        return 0;
    }
    int[] lMax = new int[nums.length];
    int[] lMin = new int[nums.length];
    int lmax = Integer.MIN_VALUE;
    int lmin = Integer.MAX_VALUE;
    int lMaxSum = 0;
    int lMinSum = 0;
    for (int i = 0; i < nums.length; i++) {
        lMaxSum += nums[i];
        lmax = Math.max(lmax, lMaxSum);
        lMax[i] = lmax;
        lMaxSum = Math.max(lMaxSum, 0);

        lMinSum += nums[i];
        lmin = Math.min(lmin, lMinSum);
        lMin[i] = lmin;
        lMinSum = Math.min(lMinSum, 0);
    }
    int[] rMax = new int[nums.length];
    int[] rMin = new int[nums.length];
    int rmax = Integer.MIN_VALUE;
    int rmin = Integer.MAX_VALUE;
    int rMaxSum = 0;
    int rMinSum = 0;
    for (int j = nums.length - 1; j >= 0; j--) {
        rMaxSum += nums[j];
        rmax = Math.max(rMaxSum, rmax);
        rMax[j] = rmax;
        rMaxSum = Math.max(0, rMaxSum);

        rMinSum += nums[j];
        rmin = Math.min(rmin, rMinSum);
        rMin[j] = rmin;
        rMinSum = Math.min(rMinSum, 0);
    }
    int diff = 0;
    for (int i = 0; i < nums.length - 1; i++) {
        diff = Math.max(diff, Math.abs(lMax[i] - rMin[i + 1]));
        diff = Math.max(diff, Math.abs(lMin[i] - rMax[i + 1]));
    }
    return diff;
}
```

## 恢复旋转排序数组

```java
//方法一：
public void recoverRotatedSortedArray(List<Integer> nums) {
    int temp = nums.get(0);
    int i;
    for (i = 0; i < nums.size(); i++) { //找到原有序数组的第一个值。
        if (nums.get(i) < temp) {
            break;
        }
    }
    if (i != nums.size()) {//将数组中旋转到前面的值按顺序加到数组末尾
        for (int j = 0; j < i; j++) {
            nums.add(nums.get(j));
        }
        nums.subList(0, i).clear();
    }
}
//方法二：同字符串的旋转，(X'Y')'=YX。
```

## 寻找旋转排序数组中的最小值

假设排好序的数组在某一未知点发生了旋转（比如**0 1 2 4 5 6 7** 可能变成**4 5 6 7 0 1 2**）。你需要找到其中最小的元素。

```java
/**
把一个排序数组先分割成两部分[first, second]，其中，first代表前面几个元素，second代表之后的元素， 例如对于数组[0, 1, 2, 4, 5, 6, 7]，可以设定first = [0, 1, 2], second = [4, 5, 6, 7]. 那么经过旋转之后，数组就变成了[second, first]，我们观察一下，这个新数组有这样两个特性：（1）second中所有元素都大于first中任意元素（2）second与first都是递增的序列
*/
public int findMin(int[] nums) {
    int left = 0;
    int right = nums.length - 1;

    while (left < right && nums[left] > nums[right]) {
        int mid = (left + right) / 2;
        if (nums[left] < nums[mid]) { //mid指在second中，而最小值肯定在mid后面
            left = mid + 1;
        } else {//mid指在first中
            right = mid;
        }
    }
    return nums[left];
}
```

## 寻找旋转排序数组中的最小值（有重复数字）

```java
public int findMin(int[] nums) {
    int low = 0;
    int high = nums.length - 1;
    while (low < high && nums[low] >= nums[high]) {
        int mid = (low + high) / 2;
        if (nums[low] < nums[mid]) {
            low = mid + 1;
        } else if (nums[low] > nums[mid]) {
            high = mid;
        } else {
            low = low + 1;
        }
    }
    return nums[low];
}
```

## 搜索旋转排序数组
```java
public int search(int[] A, int target) {
    if (A == null || A.length == 0) {
        return 1;
    }

    int start = 0;
    int end = A.length-1;
    int mid;

    while (start + 1 < end) {
        mid = start + (end - start) / 2;
        if (A[mid] == target) {
            return mid;
        }
        if (A[start] < A[mid]) {
            if (A[start] <= target && target <= A[mid]) {
                end = mid;
            } else {
                start = mid;
            }
        } else {
            if (A[mid] <= target && target <= A[end]) {
                start = mid;
            } else {
                end = mid;
            }
        }
    } 
    if (A[start] == target) {
        return start;
    }
    if (A[end] == target) {
        return end;
    }
    return 1;
}
```
## 搜索旋转排序数组 II

