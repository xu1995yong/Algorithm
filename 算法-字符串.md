## 旋转字符串

给定一个字符串和一个偏移量，根据偏移量`原地`旋转字符串(从左向右旋转)

```java
//(X'Y')'=YX。即字符串str由字符串A和字符串B组成。如果想将字符串AB翻转为BA。可以分别翻转A、B部分，得到A'B'，再翻转得到的A'B'，即可得到字符串BA。
public void rotateString(char[] str, int offset) {
    if (str == null || str.length == 0) {
        return;
    }
    offset = offset % str.length;
    reverse(str, 0, str.length - offset - 1);//A部分翻转
    reverse(str, str.length - offset, str.length - 1);//B部分翻转
    reverse(str, 0, str.length - 1);//A'B'部分翻转
}
//从start到end翻转字符串
private void reverse(char[] str, int start, int end) {
    for (int i = start, j = end; i < j; i++, j--) {
        char temp = str[i];
        str[i] = str[j];
        str[j] = temp;
    }
}
```

## 字符串的Z 字形变换

将一个给定字符串根据给定的行数，以从上往下、从左到右进行 Z 字形排列。
比如输入字符串为 `"LEETCODEISHIRING"` 行数为 3 时，排列如下：

```
L   C   I   R
E T O E S I I G
E   D   H   N
```
之后，你的输出需要从左往右逐行读取，产生一个新的字符串，比如：`"LCIRETOESIIGEDHN"`

```java
public String convert(String s, int numRows) {
    if (numRows == 1) return s;
    List<StringBuilder> rows = new ArrayList<>();
    for (int i = 0; i < Math.min(numRows, s.length()); i++) {
        rows.add(new StringBuilder());
    }
    int curRow = 0;
    boolean goingDown = false;
    for (char c : s.toCharArray()) {//将每个字符添加到所属行的stringbuilder中
        rows.get(curRow).append(c);
        if (curRow == 0 || curRow == numRows - 1) {
            goingDown = !goingDown;
        }
        curRow += goingDown ? 1 : -1;
    }

    StringBuilder ret = new StringBuilder();
    for (StringBuilder row : rows) {
        ret.append(row);
    }
    return ret.toString();
}
```

## 字符串查找

对于一个给定的 source 字符串和一个 target 字符串，你应该在 source 字符串中找出 target 字符串出现的第一个位置(从0开始)。如果不存在，则返回 `-1`。

```java
//方法一
public int strStr(String source, String target) {
    if (source == null || target == null) {
        return -1;
    }
    for (int i = 0; i < source.length() - target.length() + 1; i++) {
        int j = 0;
        for (j = 0; j < target.length(); j++) {
            if (source.charAt(i + j) != target.charAt(j)) {
                break;
            }
        }
        // finished loop, target found
        if (j == target.length()) {
            return i;
        }
    }
    return -1;
}
//方法二：KMP算法
void getNext(String pattern, int next[]) {
    int j = 0;
    int k = -1;
    int len = pattern.length();
    next[0] = -1;
    while (j < len - 1) {
        if (k == -1 || pattern.charAt(k) == pattern.charAt(j)) {

            j++;
            k++;
            next[j] = k;
        } else {

            // 比较到第K个字符，说明p[0——k-1]字符串和p[j-k——j-1]字符串相等，而next[k]表示
            // p[0——k-1]的前缀和后缀的最长共有长度，所接下来可以直接比较p[next[k]]和p[j]
            k = next[k];
        }
    }
}
public int strStr(String source, String target) {
    int i = 0;
    int j = 0;

    int[] next = new int[target.length()];
    getNext(target, next);
    while (i < source.length() && j < target.length()) {
        if (source.charAt(i) == target.charAt(j)) {
            i++;
            j++;
        } else {
            if (next[j] == -1) {
                i++;
                j = 0;
            } else {
                j = next[j];
            }
        }
        if (j == target.length()) {
            return i - j;
        }
    }
    return -1;
}
```

## 最小覆盖子串

给定一个字符串 S 和一个字符串 T，请在 S 中找出包含 T 所有字母的最小子串。

```java
public String minWindow(String source, String target) {
    String result = "";
    if ("".equals(source) || "".equals(target)) {
        return result;
    }
    int[] sHash = new int[128];
    int[] tHash = new int[128];
    for (char ch : target.toCharArray()) {
        tHash[ch]++;
    }
    int count = 0;
    int start = 0;
    int min = Integer.MAX_VALUE;
    int minS = -1;
    int end = source.length() - 1;
    for (int i = 0; i < source.length(); i++) { //对source字符串进行遍历
        sHash[source.charAt(i)]++; // 在sHash中记录每一个字符出现的频数
        if (sHash[source.charAt(i)] <= tHash[source.charAt(i)]) { // 说明该字符在target中出现过
            count++;
        }
        if (count == target.length()) { // 找到了一个子串
            // 为了让start指向第一个符合要求的字符。
            while (start < i && (sHash[source.charAt(start)] > tHash[source.charAt(start)])) {
                sHash[source.charAt(start)]--;// 还原无效的字符的频数
                start++;
            }
            if (i - start < min) {
                min = i - start;
                System.out.println(min);
                end = i;
                minS = start;
            }
            // 继续寻找下一个子串，start加1，复原freq在start位置的频数，count减1。
            // 因为答案的子串中的字母与target不需要具有相同的顺序
            sHash[source.charAt(start)]--;
            start++;
            count--;
        }
    }
    if (minS == -1) {
        return "";
    }
    return source.substring(minS, end + 1);
}
```

## 字母异位词分组

给定一个字符串数组，将字母异位词组合在一起。字母异位词指字母相同，但排列不同的字符串。

```java
public List<List<String>> groupAnagrams(String[] strs) {
    Map<String, List> ans = new HashMap<>();
    int[] count = new int[26];
    for (String s : strs) {
        Arrays.fill(count, 0);
        for (char c : s.toCharArray()) {
            count[c - 'a']++;
        }
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < 26; i++) {
            sb.append('#');
            sb.append(count[i]);
        }
        String key = sb.toString();
        if (!ans.containsKey(key)) {
            ans.put(key, new ArrayList());
        }
        ans.get(key).add(s);
    }
    return new ArrayList(ans.values());
}
```